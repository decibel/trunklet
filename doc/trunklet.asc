trunklet
========
Jim C. Nasby <Jim.Nasby@BlueTreble.com>
v0.0.1, January 2015:
Initial draft.


= API

== Template Languages
Trunklet is designed to allow for multiple different templating languages to be
defined. This allows working in whatever template language is most comfortable to you.

To support maximum flexibility, Trunklet uses the
http://pgxn.org/dist/variant[Variant data type] for defining both templates and
sets of parameters to use with a template. It is up to the template language
implementation to decide what actual data type to use.

=== template_language__add
`template_language__add( language text, process_function_definition text, extract_parameters_definition text ) RETURNS void`
Add a new template language. Besides supplying a name for your language, you must also create a process() function. Trunklet will actually create the function for you. In particular, it will generate a name for the function. So `process_function_definition` must be a valid function definition statement, excluding `CREATE FUNCTION`, the function name, arguments and RETURN clause. The function must accept `(template variant(trunklet_template), parameters variant(trunklet_parameter)[])`, where template is the template definition and parameters is an array of parameters. If an array of parameters doesn't make sense (ie: if parameters are specified via JSON) then the function should verify there is only one element in the array (TODO: allow telling Trunklet that this is the case and have it enforce this). The function must return text. (Should we also support returning variant? Presumably all templates are ultimately text, so I don't think so.)

`extract_parameters_definition` is the same as `process_function_definition` except it is to support the <<extract_parameters>> function. See <<extract_parameters>> for details.

// TODO: Example

=== template_language__remove
`template_language__remove( language text ) RETURNS void` (TODO)
Remove an existing template language. This will fail if there are any stored templates.

[[Storing_templates]]
== Storing Templates
You can have Trunklet store frequently used templates for you, so that you can refer to them with just a name.

=== template__store
`template__store( language text, template_name text[, template_version int], template variant(trunklet_template) ) RETURNS void`
Store a template. `template_name` and `template_version` must be unique across ALL templates, regardless of language. Any template with `_` as the first character will be considered to be ``hidden'', meaning it will not show up in template listings. If template_version is not specified it defaults to `1`.

NOTE: In the future we may add a `template_specification` type or something similar that allows for something finer-grained than a text field for identifying templates. Ideally this would even allow for users to add their own fields. Ideas on this welcome.

=== template__remove
`template__remove( language text, template_name text[, template_version int] ) RETURNS void`
Remove the specified template. `template_version` defaults to 1 if not specified.

== Usage Functions
These are the functions you will use most commonly when dealing with templates. Most of these functions have two versions; one that accepts the name of a template language and an actual template, and a second that accepts a template name and an optional template version. If the template version is omitted the version of the template with the highest version number is used.

IMPORTANT: These function treat a missing version number differently than the functions for <<Storing_templates>> do. Don't get the two confused!

=== process
------------
process( language text, template variant(trunklet_template), parameters variant(trunklet_parameter) ) RETURNS text
process_array( language text, template variant(trunklet_template)[], parameters variant(trunklet_parameter) ) RETURNS text[]
process( template_name text[, template_version int], parameters variant(trunklet_parameter) ) RETURNS text
process_array( template_name text[, template_version int], parameters variant(trunklet_parameter) ) RETURNS text[]
------------
Process the specified template and return the resulting text. The `_array` versions are the same, except they will accept an array of templates. Note that the `_array` versions must be passed a true array and vice-versa. This is especially important with named templates; you must know ahead of time what the template is expecting.

Note that some template languages will use an array of parameters (ie: an array of http://pgxn.org/dist/pair[pairs]), while others will accept only a single element that defines the parameters (ie: a JSON document). In order to support this, Trunklet supplies functions that accept parameters an either `variant` or `variant[]`, where the non-array version is a simple wrapper around the array version. You should always call the version that is appropriate for the template language you're using.

NOTE: We don't simply overload `process( language text, template variant(trunklet_template), parameters variant(trunklet_parameter) )` for the `_array` variation because we can't do that with the version that accepts a template name. It's better to be unambiguous here.

=== execute
------------
execute( language text, template variant(trunklet_template), parameters variant(trunklet_parameter) ) RETURNS void
execute( language text, template variant(trunklet_template), parameters variant(trunklet_parameter)[] ) RETURNS void
execute( template_name text[, template_version int], parameters variant(trunklet_parameter) ) RETURNS void
------------
Call <<process>> and execute the result as SQL. This is an easy way to generate and execute dynamic commands.

// TODO: Example

NOTE: Because these functions always return void we can overload the array version instead of requiring separate `execute_array` functions. We might add explicit `_array` versions in the future. The version that accepts a named template will always do the correct thing.

=== execute_into
------------
execute_into( language text, template variant(trunklet_template), parameters variant(trunklet_parameter) ) RETURNS variant(trunklet_return)
execute_into_array( language text, template variant(trunklet_template)[], parameters variant(trunklet_parameter) ) RETURNS variant(trunklet_return)[]
execute_into( template_name text[, template_version int], parameters variant(trunklet_parameter) ) RETURNS variant(trunklet_return)
execute_into_array( template_name text[, template_version int], parameters variant(trunklet_parameter) ) RETURNS variant(trunklet_return)[]
------------
This is the same as <<execute>>, except we capture the results of the executed SQL. Note that variant currently does not support returning record types.

=== extract_parameters
----
extract_parameters( template_name text[, template_version int], parameters variant(trunklet_parameter), extract_list text[] ) RETURNS variant(trunklet_parameter)
----
Return a specified set of parameter values. This takes `parameters` and filters it to only return parameters whose name matches one of the names in `extract_list`.


== Variant Modifier
The variant type supports http://pgxn.org/dist/variant/doc/variant.html#Variant.modifier[specifying a type modifer]. Trunklet makes use of 3 specific variant modifiers:

* trunklet_template: Used to store templates
* trunklet_parameter: Used to store parameters for templates
* trunklet_return: Used to return data from an execute_into

= Implementation

=== Copyright and License
Copyright (c) 2015 Jim C. Nasby.
